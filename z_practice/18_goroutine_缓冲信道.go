package main

import "fmt"

/*
缓冲这个词意思是，缓冲信道不仅可以流通数据，还可以缓存数据。它是有容量的，存入一个数据的话 , 可以先放在信道里，不必阻塞当前线而等待该数据取走。
当缓冲信道达到满的状态的时候，就会表现出阻塞了，因为这时再也不能承载更多的数据了，「你们必须把 数据拿走，才可以流入数据」。
在声明一个信道的时候，我们给make以第二个参数来指明它的容量(默认为0，即无缓冲)
*/
func main() {
	ch1 := make(chan int, 3) //声明一个可以缓冲3个元素的通道
	ch1 <- 1
	ch1 <- 2
	ch1 <- 3
	//ch1 <- 4 //缓冲信道会在满容量的时候加锁
	fmt.Println(<-ch1)
	fmt.Println(<-ch1)
	fmt.Println(<-ch1)
	fmt.Println("-----------------------------------")

	ch1 <- 10
	ch1 <- 20
	ch1 <- 30
	for v := range ch1 { //会报死锁错误的，原因是range不等到信道关闭是不会结束读取的。也就是如果 缓冲信道干涸了，那么range就会阻塞当前goroutine, 所以死锁
		fmt.Println(v)
		if len(ch1) <= 0 { // 如果现有数据量为0，跳出循环
			break
		}
	}

	fmt.Println("------------------ 关闭信道 -----------------")
	ch1 <- 100
	ch1 <- 200
	ch1 <- 300

	close(ch1) //显式地关闭信道 被关闭的信道会禁止数据流入, 是只读的。我们仍然可以从关闭的信道中取出数据，但是不能再写入数据了。

	for v := range ch1 {
		fmt.Println(v)
	}
	//ch1 <- 100	//panic: send on closed channel
}
